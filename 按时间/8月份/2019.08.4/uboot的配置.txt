4.1 uboot主Makefile的分析
    1.uboot版本号的确定(uboot version)
	 uboot的版本号分为四个部分
	 VERSION = 1         主版本
     PATCHLEVEL = 3      次版本
     SUBLEVEL = 4        再次版本
     EXTRAVERSION =      附加信息
     U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
	 在主makefile的开头，大概24行
	2.VERSION_FILE = $(obj)include/version_autogenerated.h   因为时=，所以Obj的值需要往下找，obj为空
	  该文件是编译过程生成的文件，里面的内容是一个宏定义，宏定义的值是uboot的配置版本号
	3.两个环境变量，HOSTARCH和HOSTOS (用export导出的是环境变量)
	  $(shell pwd) 和 `pwd`  一样
	  shell中的 |为管道，及把管道前的运算时输出当作管道后的输入
	  HOSTARCH := $(shell uname -m | \
	     sed -e s/i.86/i386/ \
	    -e s/sun4u/sparc64/ \
	    -e s/arm.*/arm/ \
	    -e s/sa110/arm/ \
	    -e s/powerpc/ppc/ \
	    -e s/ppc64/ppc/ \
	    -e s/macppc/ppc/)
      如果查出时i686替换成i386     sed -e 是替换
      HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
	  sed -e 's/\(cygwin\).*/cygwin/')
	  结果是小写的：linux
	  HOSTARCH:主机架构 HOST 主机，开发用的电脑 arch 架构的缩写 uname -m查看
	  HOSTOS 主机系统  uname -s查看
	4.静默编译  50-54
	  ifeq (,$(findstring s,$(MAKEFLAGS)))
      XECHO = echo
      else
      XECHO = :
      endif
	  正常编译会打印出一些信息,上方是静默编译的代码
	  实现静默编译的方法是 make -s
	  -s会通过MAKEFLAGS传给makefile，上述代码执行后XECHO变了为空，静默编译
	5.两种编译方法(原地编译和单独输出文件编译)单独输出文件编译方式是模仿linux kernel，78-91
	  ifdef O
      ifeq ("$(origin O)", "command line")
      BUILD_DIR := $(O)
      endif
      endif
      ifneq ($(BUILD_DIR),)
      saved-output := $(BUILD_DIR)
      # Attempt to create a output directory.
      $(shell [ -d ${BUILD_DIR} ] || mkdir -p ${BUILD_DIR})
	  默认情况下，当前文件夹.c文件编译出来的.o文件或其他文件会放在同一文件夹(原地编译)，但是原地编译污染了本身
	  的文件夹，并且一套代码只能按照一种配置方式编译
	  单独输出文件夹编译:在编译时，另外指定一个输出目录，生成的.o或其他文件在输出目录
	  两种方式:1.make O=输出目录2.先导出环境变量export BUILD_DIR=/tmp/build然后make
	  如果两个都指定，	O=xxx优先更高
	  make O=output/ distclean
	  make O=output/ x210_sd_config   //需要在output文件夹建立需要的文件夹
	  make O=output/ all
	6.
	