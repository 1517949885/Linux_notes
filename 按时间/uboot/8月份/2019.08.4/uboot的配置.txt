经过分析，大概是这样的，再makefile中执行shell命令如果有在命令行输出结果，必须赋给变量，没有结果输出的不用
例如
$(shell [ -d a ]||mkdir a)
a=(shell [ -d a ]||echo 123)
4.1 uboot主Makefile的分析
    1.uboot版本号的确定(uboot version)
	 uboot的版本号分为四个部分
	 VERSION = 1         主版本
     PATCHLEVEL = 3      次版本
     SUBLEVEL = 4        再次版本
     EXTRAVERSION =      附加信息
     U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
	 在主makefile的开头，大概24行
	2.VERSION_FILE = $(obj)include/version_autogenerated.h   因为是=，所以Obj的值需要往下找，obj为空
	  该文件是编译过程生成的文件，里面的内容是一个宏定义，宏定义的值是uboot的配置版本号
	3.两个环境变量，HOSTARCH和HOSTOS (用export导出的是环境变量)
	  $(shell pwd) 和 `pwd`  一样
	  在makefile中要使用shell 命令必须加shell 例如$(shell pwd)
	  shell中的 |为管道，及把管道前的运算时输出当作管道后的输入
	  例子
      test = abcdefghisdabcjsdlfkj
      test2 = $(test) | sed -e 's/abc/123/g'
      debug:
        @echo $(test)
        @echo $(test2)	
      结果		
      abcdefghisdabcjsdlfkj
      123defghisd123jsdlfkj
	  abc被替换成了123，如果不加字母g，结果就变成了只有第一个abc被替换
	  HOSTARCH := $(shell uname -m | \
	     sed -e s/i.86/i386/ \
	    -e s/sun4u/sparc64/ \
	    -e s/arm.*/arm/ \
	    -e s/sa110/arm/ \
	    -e s/powerpc/ppc/ \
	    -e s/ppc64/ppc/ \
	    -e s/macppc/ppc/)
      如果查出时i686替换成i386     sed -e 是替换
      HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
	  sed -e 's/\(cygwin\).*/cygwin/')
	  结果是小写的：linux
	  HOSTARCH:主机架构 HOST 主机，开发用的电脑 arch 架构的缩写 uname -m查看
	  HOSTOS 主机系统  uname -s查看
	4.静默编译  50-54
	  makefile下的函数findstring举例
	  str1:a b c
	  str1:a b c
	  all:
	       echo $(findstring a,$str1)
		   echo $(findstring a,$str2)
	  第一个返回a，第二个返回空
	  ifeq (,$(findstring s,$(MAKEFLAGS)))
      XECHO = echo
      else
      XECHO = :
      endif
	  正常编译会打印出一些信息,上方是静默编译的代码
	  实现静默编译的方法是 make -s
	  -s会通过MAKEFLAGS传给makefile，上述代码执行后XECHO变了为空，静默编译
	5.两种编译方法(原地编译和单独输出文件编译)单独输出文件编译方式是模仿linux kernel，78-91
	  makefile下的函数origin举例
	  作用是告诉你变量是哪里来的，如果变量来自命令行则为command line
	  ifdef O
      ifeq ("$(origin O)", "command line")
      BUILD_DIR := $(O)
      endif
      endif
      ifneq ($(BUILD_DIR),)
      saved-output := $(BUILD_DIR)
      # Attempt to create a output directory.
      $(shell [ -d ${BUILD_DIR} ] || mkdir -p ${BUILD_DIR})
	  默认情况下，当前文件夹.c文件编译出来的.o文件或其他文件会放在同一文件夹(原地编译)，但是原地编译污染了本身
	  的文件夹，并且一套代码只能按照一种配置方式编译
	  单独输出文件夹编译:在编译时，另外指定一个输出目录，生成的.o或其他文件在输出目录
	  两种方式:1.make O=输出目录2.先导出环境变量export BUILD_DIR=/tmp/build然后make
	  如果两个都指定，	O=xxx优先更高
	  make O=output/ distclean
	  make O=output/ x210_sd_config   //需要在output文件夹建立需要的文件夹
	  make O=output/ all
	6.如果是相对路径转换成绝对路径
	  BUILD_DIR := $(shell cd $(BUILD_DIR) && /bin/pwd)
      $(if $(BUILD_DIR),,$(error output directory "$(saved-output)" does not exist))
      endif # ifneq ($(BUILD_DIR),)
	7.四个环境变量:
	  OBJTREE:编译生成的.o文件存放目录的根目录，默认编译目录是当前目录
	  SRCTREE:源代码的根目录，当前目录
	  默认编译以上路径相同,在指定路径的编译下不相等 
	  TOPDIR
	  LNDIR
	  TOPDIR		:= $(SRCTREE)
      LNDIR		:= $(OBJTREE)
	  makefile之if函数
	  $(if <condition>,<then-part> )
      或
      $(if <condition>,<then-part>,<else-part> )
	  if函数的返回值是，如果<condition>为真（非空字符串），那个<then-part>会是整个函数的返回值，
      如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，
	  那么，整个函数返回空字串。
	8. MKCONFIG:Makefile中定义的一个变量，代表源码根目录mkconfig文件(101行)
	   MKCONFIG	:= $(SRCTREE)/mkconfig
       export MKCONFIG
	   这个脚本在后面讲解
	9.ifeq ($(obj)include/config.mk,$(wildcard $(obj)include/config.mk))
	  判断$(obj)include/config.mk文件是否存在
	  include $(obj)include/config.mk    133行左右
	  include/config.mk不是源码自带的，是在make x210_sd_config配置过程中自动生成的。
      config.mk(一个脚本)里面是一些配置，这些配置值来自2589行的配置项，想要改正配置值可以
      去2589行去改。ARCH CPU BOARD VENDOR SOC
	  ARCH   = arm
      CPU    = s5pc11x
      BOARD  = x210
      VENDOR = samsung
      SOC    = s5pc110
	  之所以不给出五个环境变量的值，是因为这样容易被集中配置更改
	10.接下来的两个重要的环境变量
      ARCH:	上述配置的值，意义是当前编译的目标CPU的架构，他的值会影响CROSS_COMPILE环境变量的值
	  CROSS_COMPILE定义交叉编译工具链的前缀，后面用这些前缀加上后缀定义编译过程用到的各种工具链
	  的工具。(136-182)
	  CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-
	  把前缀和后缀分开还有一个原因，不同cpu架构下的交叉编译工具链，只是前缀不一样，后缀一样，这样只需要区分
	  前缀，实现可移植性
	  实际运用是可以改变CROSS_COMPILE，也可以编译时make CROSS_COMPILE=xxx来实现
	11.include $(TOPDIR)/config.mk  导入文件，主目录下
	   在config.mk中  97-104  编译工具的定义
	    例如:AS	= $(CROSS_COMPILE)as
	   sinclude出现错误警告不输出命令行
	   sinclude $(OBJTREE)/include/autoconf.mk   112行，不是配置过程生成的，配置过程生成了include/config.h
	   这个文件用来指导整个uboot的编译，是由很多C0NFIG_开头的宏组成(变量)，影响编译过程的走向(原理是条件编译)
	   这个条件编译用来实现可移植性。配置过程需要原材料产生，原材料在源码目录include/configs/xxx.h（本开发板
	   x210_sd.h,内容全部为宏定义，每个开发板对应一个头文件)
	12.编译属性的配置信息，一些包含.mk文件 112-130行
	   142-149
	   链接脚本:如果定义了CONFIG_NAND_U_BOOT(在生成的autoconfig.mk文件中查看)则链接脚本叫u_boot_nand.lds
	   否则定义了u_boot.lds,我们使用的210是inand。链接文件在board文件夹中，分析编译链接过程考虑这个脚本
	   56-158
	   TEXT_BASE:在Makefile配置开发板时,在board/samsung/x210下生成config.mk,其中的内容就是TEXT_BASE
	   TEXT_BASE是将来整个uboot链接时链接地址，uboot使用了地址映射C3E00000地址等于23e00000(虚拟地址映射)
	   239-256
	   自动推导规则