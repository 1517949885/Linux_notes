	与mkconfig有关，在配置生成，与makefile有关，在编译阶段生成
1.引入start.S文件
    在u-boot.lds中找到uboot的入口(start.S的_start)（c语言的入口是main函数,uboot有汇编，需要在链接脚本找
	ENTRY()的地方，即为程序的起始代码）
	可以用sourceInsight查找   R符号
	.globl _start  使用.globol声明全局符号_start，整个程序的入口取决于链接脚本中的ENTRY声明的地方
    ENTRY(_start),_start所在处的代码就是整个程序的起始代码
2.分析start.S文件1
    头文件的包含
	#include <config.h>     config.h是配置过程生成的文件，内容#include <configs/x210_sd.h>
	#include <version.h>    version.h中包含了include/version_autogenerated.h,这个编译产生，是版本号
	#include <asm/proc/domain.h>，asm目录是配置时创建的符号链接，实际指向asm-arm为了可移植性，start.S
	源代码中头文件用的都是符号链接，这样源代码就不需要改了，只需要不同硬件移植时配置不同，创建的符号链
	接指向不同，就具有了可移植性proc也是符号链接，是proc-arm，相当于asm-arm/proc-arm/domain.h，如果没有
	符号链接，则会编译出错，找不到头文件。
3.分析start.S文件2
    #if defined(CONFIG_EVT1) && !defined(CONFIG_FUSED)
	.word 0x2000
	.word 0x0
	.word 0x0
	.word 0x0
    #endif
	.word 伪指令相当于int
	启动代码的16字节校验头(USB启动不需要，SD卡需要，mkv210image.C文件会生成)
    uboot这里start.S文件在开头位置放置了16个字节的填充。后面有具体的计算。
	异常向量表
    _start: b	reset	
	ldr	pc, _undefined_instruction
	ldr	pc, _software_interrupt
	ldr	pc, _prefetch_abort
	ldr	pc, _data_abort
	ldr	pc, _not_used
	ldr	pc, _irq
	ldr	pc, _fiq
	异常向量表是硬件决定的，软件只是参照硬件的设计来实现
	异常向量表的每种异常都应该被处理。uboot阶段并未很细致的处理处理各种异常。
	reset处才是有意义代码的开始。
	.balignl 16,0xdeadbeef  伪指令，这句话是让当前地址对齐排布，如果不对齐，自动向后走地址直到对齐，用
	0xdeadbeef填充
	.balignl 16,0xdeadbeef  它的意思就是在以当前地址开始，在地址为16的倍数的指令位置的上一个指令填入
	为0xdeadbeef的内容,此时当前地址刚好0x3c=60,由于ARM每个指令间隔4个字节,且64%16=0,所以在0x3c中填入0xdeadbeef。
    TEXT_BASE(100行,源代码中没有定义)
	makekfile配置阶段的TEXT_BASE,uboot的链接地址，0XC3E00000，makefile中变量可以传递到源代码代码使用。
4.分析start.S文件3	
	CFG_PHY_UBOOT_BASE 33e00000  uboot在ddr的物理地址，虚拟地址时C3E00000
	中断相关的在uboot一般不用
	//复位默认就是SVC模式，uboot一直在SVC模式
	msr	cpsr_c, #0xd3		@ I & F disable, Mode: 0x13 - SVC，//禁止FIQ,IRQ，ARM状态，SVC模式
	向CPSR写C域，最后的8位
	cpu底层的一些初始化
	cpu_init_crit:
	    一段无用代码
		bl	disable_l2cache  //禁止l2cache
	    bl	set_l2cache_auxctrl_cycle  //l2cache初始化
	    bl	enable_l2cache  //使能
		。。。。            //刷新l1cache  icache  dcache
		。。。。            //关闭MMU
		上面五步都是和cache和MMU有关的，不用细看
	225-227
	ldr	r0, =PRO_ID_BASE
    ldr	r1, [r0,#OMR_OFFSET]
    bic	r2, r1, #0xffffffc1
	在210中有一个寄存器(E0000004),这个寄存器的值是硬件根据OM的引脚设置的值，反应OM的接法，也就是启动介质
	243-264
	cmp	r2, #0x0		@ 512B 4-cycle
	moveq	r3, #BOOT_NAND

	cmp	r2, #0x2		@ 2KB 5-cycle
	moveq	r3, #BOOT_NAND

	cmp	r2, #0x4		@ 4KB 5-cycle	8-bit ECC
	moveq	r3, #BOOT_NAND

	cmp	r2, #0x6		@ 4KB 5-cycle	16-bit ECC
	moveq	r3, #BOOT_NAND

	cmp	r2, #0x8		@ OneNAND Mux
	moveq	r3, #BOOT_ONENAND

	/* SD/MMC BOOT */
	cmp     r2, #0xc
	moveq   r3, #BOOT_MMCSD	

	/* NOR BOOT */
	cmp     r2, #0x14
	moveq   r3, #BOOT_NOR
	r2不同值代表什么启动，r3的值会赋值给一个寄存器
	ldr	r0, =INF_REG_BASE
	str	r3, [r0, #INF_REG3_OFFSET]
	284-286
	ldr	sp, =0xd0036000 /* end of sram dedicated to u-boot */
	sub	sp, sp, #12	/* set stack */
	mov	fp, #0
	第一次设置栈，在SRAM中设置的。栈的地址为0xd0036000   //bl调用存的时候用的是lr,在被调用的函数中还要再次调用
	函数。lr只有一个，所以需要设置栈,这个地址是自己设定的，确保不会被占用即可。
5.分析start.S文件4  5  6
    288行
    bl	lowlevel_init	/* go setup pll,mux,memory */
    这里的lowlevel_init在board/samsumg/x210中
    第一句push	{lr}   压栈，在函数内部还有调用函数，所以需要压栈，前面已经设置过栈
	①检查复位状态:复杂CPU允许很多复位情况   //冷上电(关机直接上电)，热启动(休眠启动类似于电脑待机)，睡眠
	(低功耗)的唤醒
	//冷上电需要初始化DDR，热启动和睡眠下唤醒不需要，判断状态执行不同的操作
	②IO的恢复
	③关闭看门狗
	④一些SRAM和SROM的初始化  //外接的SRAM SROM我们可以不用管
	⑤供电锁存，100-104，110行后有意义
	⑥110-115   判断当前代码执行的位置(在DDR还是SRAM),是否跳过时钟初始化和内存初始化，低功耗唤醒在DDR中
	ldr	r0, =0xff000fff
	bic	r1, pc, r0		/* r0 <- current base addr of code */  r1=pc&(~r0)  当前运行地址
	ldr	r2, _TEXT_BASE		/* r1 <- original base addr in ram */链接地址加载到r2
	bic	r2, r2, r0		/* r0 <- current base addr of code */  r2=r2&(~r0)
	cmp     r1, r2                  /* compare r0, r1                  */
	beq     1f			/* r0 == r1 then skip sdram init   */
	注:
	adr r0 _start   //加载_start当前运行地址
	ldr r0 _start   //加载_start链接地址
    ⑦system_clock_init  初始化时钟   当前文件205-385行
	   x210_sd.h  300-428决定时钟怎么配置，这些宏定义决定210的时钟配置。
	⑧mem_ctrl_asm_init   初始化DDR
	函数位置在uboot/cpu/s5pc11x/s5pc110/cpu_init.S    1-581行
	初始化DDR的代码与裸机的代码类似，不一样的是DMC0_MEMCONFIG_0在逻辑中是0x20e01323,在uboot中是0x30F01313
	在裸机中DCM0的256M内存地址范围是0x20000000-0x2fffffff
	在uboot中DCM0的256M内存地址范围是0x30000000-0x3fffffff
	可以通过软件配置DCM0的起始地址(我们硬件接在DCM0的是256M)
	在uboot中，可用的物理地址范围是0x30000000-0x4ffffff，一共是512M，0x30000000-0x3fffffff是DCM0，
	0x40000000-0x4fffffff是DCM1.
	宏定义在x210_sd.h的438-468，分析时注意条件编译，时钟不同，内存配置值不一样。
	⑨uart_asm_init   初始化串口  本文件的415-432行
	串口打印"O"
	⑩tzpc_init   127行
	
	返回前，串口打印“K”
	pop {pc}  返回
	lowlevel_init执行完会打印出来OK
6.start.S的解析7	
    ①292-294行
     又一次供电锁存，无意义
    ②297-299行
     第二次设置栈，在SDRAM中设置栈(DDR已经被初始化过了)，第一次是在SRAM设置的栈，空间有限，空间有限
	 ldr	sp, _TEXT_PHY_BASE	/* setup temp stack pointer */   33e00000   ARM的栈是满减栈，与uboot代码
	 //地址一样，不过代码向上，栈是满减栈
	 sub	sp, sp, #12
	 mov	fp, #0	
	 ③判断在哪运行  305-310，是否执行代码重定位。(将uboot的第二部分(全部)加载到DDR)，第一次判断是为了是否执行时钟，DDR初始化。
	 此时uboot的第一阶段已经即将结束了，结束之前把uboot的第二部分加载到DDR中（33e00000）
	 
	 ldr	r0, =0xff000fff
	 bic	r1, pc, r0		/* r0 <- current base addr of code */
	 ldr	r2, _TEXT_BASE		/* r1 <- original base addr in ram */
	 bic	r2, r2, r0		/* r0 <- current base addr of code */
	 cmp     r1, r2                  /* compare r0, r1                  */
	 beq     after_copy		/* r0 == r1 then skip flash copy   */
	 ④312-355  重定位
	 D0037488  在内部SRAM中，这个地址的值是被硬件自动设置的，硬件根据SD卡在哪个通道，会将这个地址设置为
	 相应的数字SD0:eb000000   SD2:EB200000
	 这里是自己添加的程序，与下面程序有一致部分。
	 #if defined(CONFIG_EVT1)
	 /* If BL1 was copied from SD/MMC CH2 */
	 ldr	r0, =0xD0037488
	 ldr	r1, [r0]
	 ldr	r2, =0xEB200000
	 cmp	r1, r2
	 beq     mmcsd_boot
	 在260行确认怎么确定，在278行写入了一个寄存器	
	 ldr	r0, =INF_REG_BASE
	 str	r3, [r0, #INF_REG3_OFFSET] 
	 ldr	r0, =INF_REG_BASE
	 ldr	r1, [r0, #INF_REG3_OFFSET]
	 cmp	r1, #BOOT_NAND		/* 0x0 => boot device is nand */
	 beq	nand_boot
	 cmp	r1, #BOOT_ONENAND	/* 0x1 => boot device is onenand */
	 beq	onenand_boot
	 cmp     r1, #BOOT_MMCSD
	 beq     mmcsd_boot
	 cmp     r1, #BOOT_NOR
	 beq     nor_boot
	 cmp     r1, #BOOT_SEC_DEV
	 beq     mmcsd_boot
     确认为SD卡跳入mmcsd_boot
	 mmcsd_boot:
     #if DELETE
	     ldr     sp, _TEXT_PHY_BASE      
	     sub     sp, sp, #12
	     mov     fp, #0
     #endif
	     bl      movi_bl2_copy
	     b       after_copy
	 正真的重定位是movi_bl2_copy，是个C文件，在uboot/cpu/s5pc11x/movi.c  //复制代码
	 copy_bl2(2, MOVI_BL2_POS, MOVI_BL2_BLKCNT,CFG_PHY_UBOOT_BASE, 0);
	 第一个参数表示通道2，第二个参数是uboot第二部分在SD卡中开始的扇区，第三部分是UBOOT的大小，占用的扇区数
	 第四部分是SDRAM的地址
7.start.S的解析9 
     虚拟地址映射
     物理地址:物理设备生产时赋予的地址，裸机中寄存器地址都是物理地址,物理地址是硬件编程，物理地址是确定好的，无法通过编程修改
     虚拟地址:在软件操作和硬件被操作之间增加一个层，虚拟地址映射层。软件操作给虚拟地址，硬件操作还是
     原来的物理地址，映射层建立一个软件层到硬件层的映射表。虚拟地址到物理地址的映射是不可能通过软件来实现的
     MMU单元的作用   memory management uint  内存管理单元
     MMU:内存管理单元,SOC的一个硬件单元，主要功能是实现虚拟地址到物理地址的映射。
	 MMU单元在CP15协处理器中进行控制，要控制MMU单元，就是对协处理的寄存器进行操做
	 地址映射的额外收益
	 1:访问控制
	 访问控制就是:在管理上对内存进行分块，然后每块进行独立的虚拟地址映射，然后在每一块
	 的映射关系中同时还实现了访问控制(对该块可读、可写、只读、只写、不可访问等控制)
	 在c语言编程中，经常会出现一个错误:segmentation fault 段错误，这个段错误和MMU的访问控制有关，当前程序只能操作自己有权操作的
	 地址范围，程序指针出错访问了不该访问的内存块就会触发段错误
	 2:cache
	 cache的工作和虚拟地址映射的关系
	 cache是快速缓存，比CPU慢，比DDR快。把DDR中常用的内容读取到cache，cpu每次先从cache中读，没有才从ddr中读。cache大，cpu运行越快
	 ①CP15一共有16个寄存器。通过mcr,mrc来控制寄存器
	   c3寄存器在mmc中的作用是控制域访问   362-363
	   ldr	r5, =0x0000ffff
	   mcr	p15, 0, r5, c3, c0, 0		@load domain access register
	 ②设置TTB(c2寄存器)(translation table base),转换表基地址
	   转换表是建立一套虚拟地址映射的关键。
	   转换表由表索引(虚拟地址)和表项(物理地址)组成。映射中规定了内存映射和管理是以
	   块为单位的，看MMU的支持和选择，在ARM中支持三种块大小，细表1k，粗表4k,段1M。
	   正真的转换表就是由若干个转换表单元构成，每个单元负责1个内存块，负责整个空间的映射(0-	4G)。
	   建立虚拟地址映射的主要工作就是建立转换表。
	   转换表不需要软件去干涉使用，而是将基地址TTB放在CP15的c2寄存器，MMU工作时会自动查表。
	   要SDRAM的转换表基地址，此时运行地址可能还不在SDRAM 
	   	ldr	r0, _mmu_table_base
	    ldr	r1, =CFG_PHY_UBOOT_BASE
	    ldr	r2, =0xfff00000
	    bic	r0, r0, r2
	    orr	r1, r0, r1
	    mcr	p15, 0, r1, c2, c0, 0
	 ③使能MMU，开启MMU(c1寄存器)
	 	mrc	p15, 0, r0, c1, c0, 0
	    orr	r0, r0, #1
	    mcr	p15, 0, r0, c1, c0, 0
	 ④转换表的分析   (lowlevel_init.S   593行)
	   从宏观上上来看，整个转换表可以看做是一个int类型的数组，数组中的元素值就是表项，
	   数组下标就是表索引。
	   ARM的段是映射长度为1M，因此一个映射单元只能管1M。4096个映射单元，把4096个单元分为几部分，用循环赋值每单元
	   	.set __base,0
	   // Access for iRAM
	   .rept 0x100       循环0x100次
	   FL_SECTION_ENTRY __base,3,0,0,0
	   .set __base,__base+1
	   .endr
	   本开发板的映射表
	   VA(虚拟地址)                    PA(物理地址)
	   0-0x10000000                    0-0x10000000                    256M
	   0x10000000-0x20000000           0                               256M   不被允许
	   0x20000000-0x60000000           0x20000000-0x60000000           1G     0.5-1.5G
	   0x60000000-0x80000000           0                               512M   1.5-2G
	   0x80000000-0xb0000000           0x80000000-0xb0000000           768M   2-2.75G
	   0xb0000000-0xc0000000           0xb0000000-0xc0000000           256M   2.75-3G
	   0xc0000000-0xd0000000           0x30000000-0x40000000           256M   3-3.25G
	   0xd0000000-完                   0xd0000000-0x完                 768M   3.25-4G
	   
	   
	   DRAM有效范围
	   DCM0:0x30000000-0x3FFFFFFF
	   DCM1:0x40000000-0x4FFFFFFF
	   虚拟地址0xc0000000映射到物理地址0x30000000
	   配置时将链接地址设置为0Xc3E00000,因为这个地址被映射到0x33e00000，MMU开启后，只能用虚拟地址
7.start.S的解析10
    第三次设置栈(DDR中设置栈)，虽然已经再 DDR中设置过一次栈，本次设置栈放到合适的位置(安全，紧凑而不浪费)
	ldr	sp, =(CFG_UBOOT_BASE + CFG_UBOOT_SIZE - 0x1000)，在uboot上方，大小是2M-uboot的大小(大概200k)-0x1000(4k),大概1.8M，既安全，又不浪费
	清理bss段
	ldr伪指令加载链接地址，=加载立即数，符号加载地址的值。bss开头结尾的是从u-boot.lds得到的
	第一段结束
	ldr	pc, _start_armboot
	start_armboot在uboot/lib_arm/board.c中，是c文件，这个函数是uboot的第二阶段，这
	句代码的作用是实际上就是一个远跳转直接跳到DDR中的第二阶段开始地址处。是第一阶段和
	第二阶段的分界线。
	
	
	
	总结
	构建异常向量表
	关看门狗，供电锁存
	时钟初始化，DDR初始化，串口初始化打印OK等
	重定位复制代码，建立映射表，开MMU，设置栈跳转到第二阶段


















































