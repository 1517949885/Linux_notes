1.一级指针
    指针的类型:从语法角度，只要把声明指针声明语句中的指针名字去掉，剩下的部分就是这个指针的类型
	(1)int*ptr;//指针的类型是int*
    (2)char*ptr;//指针的类型是char*
    (3)int**ptr;//指针的类型是int**
    (4)int(*ptr)[3];//指针的类型是int(*)[3]
    (5)int*(*ptr)[4];//指针的类型是int*(*)[4]
	指针所指向的类型:从语法角度，只要把声明指针声明语句中的指针名字和名字左边的指针指针声明符*去掉，
	剩下的就是所指向的类型
    (1)int*ptr; //指针所指向的类型是int
    (2)char*ptr; //指针所指向的的类型是char
    (3)int**ptr; //指针所指向的的类型是int*
    (4)int(*ptr)[3]; //指针所指向的的类型是int()[3]
    (5)int*(*ptr)[4]; //指针所指向的的类型是int*()[4]
	指针的值/指针所指向的内存区
	指针的值是指指针本身存储的数据，这个值被编译器当成一个地址，在32位程序中，指针的值都是32位的，因为
	32位程序里内存地址全是32位长，指针所指向的内存区就是从指针的值所代表的那个内存地址开始长度为sizeof
	(指针多指向的类型)大小的一片区域。
	例如:
    char a[20];
    int *ptr=(int *)a; //强制类型转换并不会改变a 的类型
    ptr++;
	在上例中，指针的类型是int*，指向的类型是int，初始化为指向整型变量a，指针ptr+1，编译器是这样处理的，
	它把指针ptr的值加上sizeof(int),在32 位程序中，是被加上了4，原来ptr 是指向数组a 的第0号单元开始的
	四个字节，此时指向了数组a中从第4号单元开始的四个字节。
	例如:
	char a[20]=" You_are_a_girl";
    char *p=a;
    char **ptr=&p;
    printf("**ptr=%c\n",**ptr);
    ptr++;
    printf("**ptr=%c\n",**ptr);
	ptr的类型是char**,指向的类型是char*,指向的地址就是P的地址(&p),当执行ptr++时，会使指针加一个sizeof(char*)
	&p+4指向的为非法操作。
	①运算符&和*
	这里&是取地址运算符，*是间接运算符
	
	