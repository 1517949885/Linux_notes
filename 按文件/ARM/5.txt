1.看门狗(看门狗定时器)
    可以提前喂狗，不能超时喂狗，如果不喂狗强制复位。数据手册7.3
	一般CPU启动后看门狗默认是工作的
	关看门狗(启动代码段我们不方便喂狗，关闭看门狗，一旦打开就要喂狗)
	iROM内部的代码已经关过看门狗了。
	涉及到的寄存器:WTCON(0xe2700000)的bit5位
	ldr r0,=WTCON
	ldr r1,=0x0
	str r1,[r0]
2.启动代码设置栈和调用C语言
    C语言运行时需要一定的条件，这些条件由汇编提供
	C语言与栈的关系，C语言的局部变量都是用栈来实现的，如果汇编中没有给C部分预先设置合理合法的栈
	C语言定义的局部变量落空，程序死机。51一些单片机编译器在链接中自动添加头，不需要自己编写。
	①在ARM中，每种模式都有自己独立的SP寄存器(r13)，防止被其他影响，一个损坏不会连累
	②我们现在设置栈，不可能设置所有的栈，我们先找到自己的模式，然后设置自己模式下合理合法的栈
	系统复位后默认在SVC模式下
	③栈必须是当前可用的一段内存(只会被用作栈，不会被其他程序征用),CPU刚复位，DDR(SDRAM)需要初始化，内部
	SRAM不需要初始化，只有在SRAM中申请一段内存作为SVC模式下的栈
	栈有四种:满减栈，满增栈，空减栈，空增栈
	满栈:进栈，先移动指针，再存     出栈，先取再移动指针
	内部SRAM 96k 0XD0020010=0XD0038000
	在ARM中，ATPCS要求使用满减栈，因此设置SVC栈空间时地址设置到三星规范栈内存的最大地址(D0037D80,看IROM手册)
	设置栈:
	ldr sp,=D0037D80
	c语言代码见其他文件
	问题:
	led.o:(.ARM.exidx+0x0): undefined reference to `__aeabi_unwind_cpp_pr1'
    led.o:(.ARM.exidx+0x8): undefined reference to `__aeabi_unwind_cpp_pr0'
	在编译器  arm-linux-gcc等编译器后加上-nostdlib,nostdlib就是不使用标准函数库
	volatile作用是让程序在编译时，编译器不对程序优化
3.启动代码开iCache
    cache是一种内存，叫高速缓存
	从速度来说:CPU>寄存器>DDR
	cache的存在，寄存器和DDR之间的速度差异，DDR的速度不能满足寄存器的需求。
	210中有32k的icache和32k的dcache,分别是缓存指令和数据
	指令平时放在硬盘/flash，运行时读到DDR，再从DDR到寄存器，再到寄存器到CPU，但是DDR太慢，拖慢CPU，
	icache的工作原理是:将CPU正在执行的指令旁边的几句指令事先读到icache。
	icache的设置在协处理器中
	开关icache
	mrc p15,0,r0,c1,c0,0  //读cp15的c1到r0
	bic r0,r0,#(1<<12)    //bit12置0   关
	orr r0,r0,#(1<<12)    //bit12置1   开
	mcr p15,0,r0,c1,c0,0  //写r0到cp15的c1
	根据代码开关icache观察现象
	关掉icache，代码速度明显变慢，可通过观察led得到
4.重定位引入和链接脚本
    ①大部分指令是位置有关编码
	  位置无关码:汇编源码编译成二进制可执行程序后和位置(内存地址)无关
	  位置有关码:汇编源码编译成二进制可执行程序后和位置(内存地址)有关
	  
	  我们在设计一个程序时，会给这个程序指定一个运行地址(链接地址)，而且必须给编译器链接器指定这个地址才行。
	  但有个别指令和位置没有关系。
	  对于位置有关代码，最终执行时的运行地址和编译链接时给定的链接地址必须相同。
	  裸机中Makefile的 -Ttext 0x0链接，虽然我们下载程序是用的d0020010,即程序运行地址，但是因为地址映射，
	  所以是一样的。
	  链接地址:链接时指定的地址(指定方式:makefile中用-Ttext或者链接脚本)
	  运行地址:程序实际运行时的地址。
	  
	  以前讲的启动方式是三星推荐的，bootloader大小小于96k
	  uboot的实际启动方式:大小任意，上电后运行BL0(IROM),将uboot的前16kBL1加载到SRAM运行，BL1会初始化DDR，
	  然后将整个uboot搬运到DDR，然后用长跳转(从SRAM跳转到DDR)指令从SRAM跳转到DDR。
	②为什么需要重定位
	  有时候链接地址和运行地址不能相同，而且必须用位置有关代码，这时候只能使用重定位
	  链接地址是有程序员编译链接的过程中，通过Makefile中-Ttext或者链接脚本中指定的。
	  举例:
	  1.linux中的应用程序  gcc hello.c -o hello   这里默认链接地址就是0x0
	  2.210的裸机程序，运行地址由下载决定(d0020010),所以从这里运行，是由IROM中BL0加载BL1时决定。
	  理论上链接地址应该是d0020010，但是裸机代码是位置无关码。
	③从源代码到可执行程序
	  预编译:预编译器执行。//编译前处理一些东西，例如宏，注释
	  编译:编译器执行。把源码(.c  .s)变成.o文件(机器码)
	  链接:链接器执行。将.o文件各函数段按一定规则累积到一起，形成可执行文件。
	  strip:把可执行程序中的符号信息拿掉。节省空间
	  objcopy:生成可烧录的镜像bin文件
	④程序段
	  段就是程序的一部分。将整个程序分为一个个段，给每个段起个名字，在链接时就可以用这个名字来指示这个
	  段。段名分为两种，一种是编译器链接器定义好的，一种是程序员定义的。
	  先天段名:代码段:(.text),又叫文本段，代码段就是函数编译后生成的东西
	           数据段:(.data),数据段是C语言中有初始化为非0的全局变量。
			   bss段:(.bss)C语言中有初始化为0的全局变量(全局变量不初始化数也是0)
	⑤链接脚本要做什么
	  链接脚本其实是规则文件，用来指挥链接器工作。
	  链接脚本的关键内容是段名(.o文件的)和地址(内存地址)
	  格式：
	  SECTIONS{}
	  .在链接脚本中表示当前位置
5.重定位
    练习思路
	1.通过链接脚本链接到0xd00024000
	2.用dnw下载是将bin文件下载到0xd00020010
	3.代码执行是通过前面一段位置无关代码搬移到0xd00024000
	4.使用一个长跳转跳转到0xd00024000处代码执行，重定位完成
	长跳转:跳转指令是通过给pc一个新的地址完成代码段的跳转。长跳转是跳转的地址差异比较大。长跳转
	会跳转到d00024000处的镜像代码中要执行的代码。ldr pc,=led_blink.短跳转则是0xd00020010处的代码。
	bl led_blink。链接地址和运行地址一样是，长短跳转一样。地址不一致是，长跳转是链接地址处的代码。
    adr和ldr伪指令的区别
    ldr是长加载，加载链接地址
	adr是短加载。加载运行地址
       adr r0,=_start 
	   ldr r1,=_start
	   ldr r2,=bss_start   //在链接脚本
	   cmp r0,r1     //比较运行地址和链接地址是否相等
	   beq clean_bss   //相等不需要重定位,如果不相等说明需要重定位
	copy_loop:   //使用循环复制代码到链接地址
	   ldr r3,[r0],#4  //相当于r3 = *(r0); r0 += 4;
	   str r3,[r1],#4   
	   cmp r1,r2     //代码段和数据段，没有bss段，全局变量为0的数据段
	   bne copy_loop
    //bss清零	   
	clean_bss:
	   ldr r0,=bss_start
	   ldr r1,=bss_end
	   cmp r0 r1      //相等bss为空
	   beq run_on_sram
	   mov r2,#0
	clear_loop:
	   str r2,[r0],#4
	   cmp r0,r1
	   bne clear_loop
	run_on_sram：
	   ldr pc,=led_blink
6.SDRAM的引入
    SDRAM:同步动态随机存储器
	SDRAM:容量大，价格低，总线式访问，需要初始化才能使用
	SDRAM的初始化:
	210共有两个内存端口，分别是DRAM0，DRAM1
	DRAM0的地址范围是:0x20000000-0x3fffffff    //512M
	DRAM1的地址范围是:0x40000000-0x7fffffff    //1G
	210在DRAM0，DRM1各分配了256M内存，共512M
	0x20000000-0x2fffffff
	0x40000000-0x4fffffff
	原理图中每个DDR端口都有三类总线:地址总线(14根)，控制总线，数据总线(32根)
	四个芯片，两两并联形成32位(单个是16位)，，分别接在两个内存端口
	210的DDR工有八个BANK，由三个管脚控制，每个bank是128Mbit，根据列地址(column adress)和行地址(row adress)
	阵列寻址，行地址14位，列地址10位，共2的24次方地址，共16MB。
7.SDRAM的初始化(sdram_init.S文件)
    初始化DDR2，数据手册第5章1.2.1.3，27个步骤
	1.设置IO端口驱动能力   2x
	2.设置时钟(128-154)
	DMC0_MEMCONTROL		0x00202400   
	DMC0_MEMCONFIG_0	0x20F01323	//高8位是起始地址，然后八位是掩码。如果0x2000_0000 ~ 0x27FF_FFFF
	//这八位是F8，高5位是0，低三位为1。我们应该设为F0，高4位是0，低4位为1.E0是512M。行列几位按实际
	//MemConfig0	256MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
        DMC0_MEMCONFIG_1	0x30F00312	// MemConfig1		默认值根据一片还是两片
	DMC0_TIMINGA_REF	0x00000618	// TimingAref	7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4E)
	DMC0_TIMING_ROW		0x28233287	// TimingRow	for @200MHz
	DMC0_TIMING_DATA	0x23240304	// TimingData	CL=3
	DMC0_TIMING_PWR		0x09C80232	// TimingPower
	命令寄存器
	DMC_DIRECTCMD
	
	
    
	
	
	
	
	
	