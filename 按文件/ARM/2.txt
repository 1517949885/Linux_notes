1.电子器件的发展方向
   模拟器件->数字器件
   ASIC->可编程器件     ASIC:专业芯片，硬件已经编程好，不能软件编程
   CPU在固定频率的时钟控制下运行
   这些可以被CPU解码执行的二进制指令集是CPU设计的时候确定的
   高级语言源代码-编译器->汇编源代码-汇编器->二进制可执行程序-
   Objcopy工具->Bin格式烧录文件-总线->CPU读入后先解码->CPU执行指令
2.指令集对CPU的意义
   汇编难写，无可移植性，但效率最高
   汇编的实质是机器指令(机器码)的助记符
   机器指令集是一款CPU的编程特征，是这款CPU的设计者制定的。CPU的内部电路设计
   就是为了实现这些指令集的功能。
   一条汇编指令和一段机器码是一一对应的。
3.RSIC和CISC
   CISC是复杂指令集(编译器好设计)
   理念是:用最少的指令来完成任务。例如CISC中有乘加指令。每个指令就是一个电路
   设计复杂，工艺复杂。CISC出现的比较早，现在Intel还在使用
   RISC是精简指令集(编译器不好设计)
   理念是:让软件来完成具体任务，CPU本身提供基本功能指令集。相对来说设计简单，
   工艺简单。例如乘加等复杂指令是由基础指令组成。
   一般典型的CISC CPU指令在300条左右
   ARM CPU(RISC)常用指令30条左右
4.统一(独立)编制、哈弗结构、冯诺依曼结构
   内存是程序的运行场所，内存和CPU通过总线连接，CPU通过一定地址来访问具体内存
   单元
   IO是输入输出接口，就是指CPU的内部和外部外设。(串口，LCD等)
   因为内存访问频率高，内存和CPU的这种总线式连接方式是一种直接连接，优点是效率
   高访问快。
   CPU访问各种外设有两种方式:1.IO与内存统一编址(与内存一样直接连接)2.IO与内存
   独立编址(使用专用的CPU指令访问某种外设)。
   程序和数据(程序运行的两大核心)
   程序是我们写好的源代码经过编译、汇编之后得到的机器码，拿给CPU解码执行。只读
   数据是程序过程中定义和产生的变量的值。可读写，程序运行实际即使为了改变变量
   冯诺依曼结果和哈佛结构
   冯诺依曼结构(Intel)
   程序和数据都放在内存中，且彼此不分离。都可读写，有安全问题
   哈佛结构(ARM)
   哈佛结构中程序(一般在ROM,FLASH中)和数据(一般在RAM)独立分开存放，好处安全稳定
   缺点软件处理复杂一些。
5.软件编程控制硬件的关键-寄存器
   寄存器属于CPU外设的硬件组成部分，寄存器是CPU的硬件设计者制定的。
   SoC中有两类寄存器：通用寄存器和SFR(特殊寄存器)
   通用寄存器(ARM有37个)是CPU的组成部分。
   SFR(不能改正)不在CPU中，存在CPU的外设中。
7.S5PV210属于Cortex-A8架构，32位CPU，32根地址线和32根数据线
   32根地址线决定CPU的地址空间为4G，4G空间如何分配就是内存映射(地址映射)
   ROM:只读存储器  read only memory
   IROM:集成到Soc内部的只读存储器  ramdom access memory
   RAM:随机访问存储器   
   IRAM:集成到Soc内部的随机访问寄存器
   DRAM:动态RAM
   SRAM:静态RAM
8.CPU和外部存储器
   内存  内部存储器  用来运行程序  RAM  举例：DRAM,SRAM,DDR
   外存  外部存储器  用来存储东西的  ROM  举例:FLASH,NAND,iNand，U盘SSD
   外存和内存的连接方式是不同的，内存通过总线，直接地址访问(好处直接访问，
   随机访问,坏处是占用CPU地址空间，大小受限)，外存是通过CPU的外存接口连接
   (好处是不占用CPU的地址空间，坏处是访问速度没总线快，时序复杂)
   Soc常用的外部存储器
   NorFlash     可以总线式访问，一般接到SROM bank，一般用来启动
   NandFlash     三星生产NandFlash,发明NandFlash启动，分为SLC(一般不出现问题)
                 和MLC     
   eMMC/iNand/moviNand  emmc(嵌入式的MMC，芯片式的MMC)iNand是SanSisk公司
                        出的eMMC，moviNand是三星出的eMMC(现在常用)
   oneNAND             三星出的NAND
   SD卡/TF卡/MMC卡     都是SD卡
   eSSD                固态硬盘(MLC)
   
   SATA硬盘
   S5PV210支持NandFlash，oneNAND，SD/MMC,eMMC,eSSD
   S5PV210共支持四个SD/MMC通道，其中通道0和通道2依次用作启动。X210开发板通道0
   连接板载MMC，因此外部启动只能使用通道2
9.S5PV210的启动过程
    1.内存
      SRAM  容量小，价格高，优点，不需要软件初始化，直接上电就能用（单片机）
      DRAM  容量大，价格低，缺点，需要软件初始化，上电后不能直接使用（PC机，
	  嵌入式）
	外存
	  NandFlash 容量大，价格低，不能总线式访问，上电后不能直接读取，需要运行
	  一段初始化软件，才能按照时序接口读取
	  NorFlash  容量小，价格低，总线式访问，CPU上电之后可以直接读取，一般用作
	  启动介质
	所以一般PC机：BIOS(NorFlash)+硬盘(类似于NandFlash)+DRAM
	单片机：NorFlash+SRAM
	嵌入式系统:外接大容量NandFlash+外接大容量DRAM+Soc内置的SRAM
	2.SVPV210的启动方式
	  210内置了一块96k大小对的SRAM(iRAM)，还有一块内置64k的NorFlash(iROM)
	    第一步：CPU上电后先从IROM(BL0)中读取预先设置的代码，执行。这些代码执行
		一些基本的初始化(CPU时钟、看门狗)。这段代码会判断选择的启动方式(读电平
		，通过硬件跳线选择)然后从相应的外部存储器读取第一部分启动代码(BL1,16k)
		，到SRAM。
	    三星出厂设置的。没有初始化DRAM
	    第二步:运行读取到的启动代码BL1，这段代码负责初始化NandFlash(也可能在
		BL0执行),然后BL2读取到IRAM，运行
		第三步:运行BL2，初始化DRAM，然后将OS读到DRAM，执行。
		BL0的代码：
		关看门狗
		初始化指令cache    //汇编语言写的
		初始化栈和堆      //才能用C语言
		初始化块设备复制函数   //提供了9个函数
		设置Soc时钟系统
		复制BL1到内部IRAM(SRAM)
		检查BL1校验和
		跳转到BL1去执行。
		
	  二次启动是SD卡通道2。一次通道启动失败则跳到二次启动。
	  先1st启动
	  再2st启动，SD2
	  再Uartqid再USB启动
11.如何再开发板上选用不同的启动方式
    1.使用板载iNand,在SD0通道的eMMC启动，内部烧录了安卓
     OM0 OM1 OM2 OM3 OM4 OM5  101100	
	2.SD通道2启动
	 二次启动，设置和一次启动即可，一次启动不成功(破坏iNand的代码)则二次启动。
    3.USB调试模式
     101101
12.
    ARM采用的是32位架构
	ARM约定
	  Byte 8bits
	  Word 32bits
	  Halfword 16bits
	大部分的ARM core提供:
	  ARM指令集(32bit)  一个指令代表32位
	  Thumb指令集(16-bit) 一个指令代表16位
	  Thumb2指令集(16&32-bit)
	ARM 有七种基本工作模式
	普通模式(Normal)
	  User:非特权模式，大部分代码执行这种模式
	特权模式(Privilege)
	  FIQ,IRQ,Supervisor,Abort,Undef,System六种
	  除了System剩下为异常模式
	各种模式的切换可以是程序员通过代码主动切换(CPSR寄存器)，也可以CPU在
	某些情况自动切换。
	操作系统有安全级别要求，因此CPU设计多种模式是为了方便操作系统的多种角色
	安全等级需要
13.ARM的37个寄存器
     1.ARM的37个寄存器，但每种模式下最多只能看到18个寄存器，其他寄存器虽然名字
	 相同，但是在当前模式不可见。
	 例如对于R14这个名字来说，在ARM中共有6个R14	,但是在每种特定的处理器模式下
	 只有一个R14是当前可见的，其他R14必须切换到他对应的模式下才能看到
     2.37个寄存器30个为通用行，1个固定PC，一个固定CPRS，5个固定SPRS。 
     3.CPRS中各个bit表明了CPU的某些状态信息
	 4.PC为程序指针，PC指向哪，CPU就执行哪条指令。
14.ARM的异常处理方式简介
     1.正常工作之外的流程都叫流程
	 异常会打断正在执行的工作，并且一般我们希望异常处理完后还会继续回来执行
	 原来的工作
	 中断是异常的一种
	 FIQ,IRQ,Supervisor本质是中断
	 2.所有的CPU都有异常向量表，这是CPU设计时设定好的，由硬件决定
	   当异常发生时，CPU会自动动作(PC跳转到异常向量处理异常)
	   异常向量表是硬件向软件提供的处理异常的支持
15.汇编指令
    指令:CPU机器码的助记符
	伪指令:本质不是指令，只是和指令写在一起，他是编译器环境提供的。用来
	知道编译过程
	ARM官方的ARM汇编风格:指令一般用大写。windows中的IDE开发环境(MDK)
	如:LDR R0 [R1]
	GUN风格的ARM风格：指令一般用小写字母，linux常用，ldr r0 [r1]
	ARM汇编的特点
	1.LDR/STR架构
	ARM采用的是RISC结构，CPU不能直接读取内存，需要先将内存中的内容加载到
	CPU通用寄存器才能被CPU处理
	ldr指令将内存内容加载到通用寄存器
	str指令将通用寄存器内容存到内存空间
	ldr/str组合用来实现ARM CPU和内存数据交换。
	2.8种寻址方式
	寄存器寻址   mov r1,r2   //将r2的值赋给r1
	立即寻址     mov r0,#0xff00  //将0xff00赋给r0
	寄存器移位寻址  mov r0,r1,lsl#3  //r1左移三位赋给r0=r1*8
	寄存器间接寻址  ldr r1,[r2]   //将r2为地址的内存的数赋给r1
	基址变址寻址    ldr r1,[r2,#4]  //r2+4位地址的内存的数赋给r1
	多寄存器寻址    ldmia r1!,{r2-r7,r12}//以r1值为首地址的数组加载到r2-r7,r12
	//r2=[r1]  r3=[r1+4]
	堆栈寻址        stmfd sp!,{r2-r7,lr}
	
	相对寻址  beq flag   //flag是标号
	3.指令后缀
	同一个指令附带不同的后缀，变成不同的指令
	B:功能不变，操作长度变为8位
	H:功能不变，操作长度变为16位
	S:功能不变，操作数变为有符号
	S:功能不变，影响CPRS标志位
	CPRS  当前的程序状态寄存器
	SPRS  保存的程序状态寄存器
	4.条件执行后缀
	moveq r0,r1  //如果eq后缀成立，则执行 mov r0,r1。不成立则作废，相当于没有
	  1.条件后缀是否成立，不是取决于本句代码，而是取决于这句代码之前的的代码
	  2.条件后缀决定这句代码，不影响其他的。
	  EQ  标志 Z=1  //CPRS中的。EQ  NE  GT  LE GE  LE
	5.多指令流水线
	  取指->解码->执行。
16.汇编指令
  1. mvn与mov用法一样，区别是mov是原封不动的传递，mvn是按位取反后传递
	 算数运算指令：add,sub,rsb,adc,sbc,rsc
	 逻辑指令:and orr eor bic
	 比较指令：cmp cmn tst ,teq
	 乘法指令：mvl,mla,umull,small,smlal
     前导零计数:clz
	 bic  位清除指令
	 bic r0,r1,#0x1f  //将r1中的数bit0到bit4清零后赋值给r0
	 //比较指令不需要加s后缀就可以影响CPRS标志位
	 cmp r0,r1   //等价于r0-r1,影响CPRS标志位
	 cmn r0,r1   //等价于r0+r1,影响CPRS标志位
	 tst r0,#0x1f  //测试bit0-bit4位是否为0,影响CPRS标志
	 teq r0,r1   //进行异或操作
  2.CPRS访问指令
     mrs&msr
	 mrs用来读prs，msr用来写prs
	 CPRS是是程序状态寄存器，Soc中有一个，SPRS有五个，分别在五种异常模式下
	 ，作用是进入异常后，用来保存之前的普通模式CPRS的值，以返回普通模式时
	 回复原来的CPRS
  3.跳转指令
     b:直接跳转
	 bl:跳转前把返回地址放到lr，以方便返回，一般用于函数调用
	 bx:跳转的时候切换到ARM模式，一般用在异常处理
	 //现在芯片一般就要ARM指令集。用不到bx
  4.访存指令
     ldr/str&ldm/stm&swp
     ldr/str   单个字/半字/字节访问
	 ldm/stm   多字节批量访问
	 swp r1,r2,[r0]  //将地址为r0的值给r1，r2的内容给r0
	 swp r1,r1,[r0]  //交换，r1=5,r0=3,执行。r0=5,r1为地址为3的数
  5.软中断指令
     swi  //用来实现操作系统中系统调用，软件模拟中断  
17.
   协处理器cp15指令
    mrc:读协处理器
    mcr:写协处理器
18
    ldr/str每周期只能访问4字节内存，如果需要批量读取，写入内存时太慢，解决
    方案是stm/ldm
	stmia sp,{r0-r12}//将r0存入sp指向的内存中，r1存到sp指向地址加4的内存
	后缀：
	ia//先传输，地址再加4
	ib//先地址加4，再传输
	da//先传输，再地址减4
	db
	fd 满递减堆栈
	ed 空递减堆栈
	fa 满递增堆栈
	ea 空递增堆栈
	四种栈
	空栈：指针指向的是空位，每次存入时可以直接存入然后堆栈指针移动一格，取
	出是先移动一格才能取出
	满栈：栈指针指向最后一格数据，每次存入先移动一格再存入取出时直接取出再
	移动栈
	增栈：栈指针移动向地址增加的方向移动
	减栈：栈指针移动时向地址减小的方向移动的的栈
	stmfd sp!,{r1-r4}
	[sp-4]=r4  [sp-8]=r3  [sp-12]=r2
	ldmfd sp!,{r1-r4}
	r1=[sp]  r2=[sp+4]
	
	ldmfd r0,{r1-r4}
	ldmfd r0!,{r1-r4}
	区别在于加！号,r0的值会改变。成为r0变成原来的值加16（相当于写入r4值的地址）
    